<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TCP 报文格式 - everystep</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/style.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../about-book.html">关于项目</a></li><li class="chapter-item affix "><li class="part-title">🌟 计算机基础</li><li class="spacer"></li><li class="chapter-item "><a href="../../os/0-summary.html"><strong aria-hidden="true">1.</strong> 操作系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../os/start/index.html"><strong aria-hidden="true">1.1.</strong> OS 启动过程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../os/start/bios.html"><strong aria-hidden="true">1.1.1.</strong> OS 启动之 BIOS</a></li><li class="chapter-item "><a href="../../os/start/boot-loader.html"><strong aria-hidden="true">1.1.2.</strong> OS 启动 Boot Loader 汇编实现细节</a></li><li class="chapter-item "><a href="../../os/start/boot-main.html"><strong aria-hidden="true">1.1.3.</strong> OS 启动 Boot Loader C语言实现细节</a></li><li class="chapter-item "><a href="../../os/start/pc-address.html"><strong aria-hidden="true">1.1.4.</strong> OS 内存地址空间的演化历程</a></li><li class="chapter-item "><a href="../../os/start/real-mold.html"><strong aria-hidden="true">1.1.5.</strong> OS 实模式、保护模式</a></li><li class="chapter-item "><a href="../../os/start/seg-page.html"><strong aria-hidden="true">1.1.6.</strong> OS 分段、分页</a></li></ol></li><li class="chapter-item "><a href="../../os/kern/index.html"><strong aria-hidden="true">1.2.</strong> OS 内核</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../os/kern/os-asm.html"><strong aria-hidden="true">1.2.1.</strong> OS 内核入口实现细节</a></li><li class="chapter-item "><a href="../../os/kern/os-stack.html"><strong aria-hidden="true">1.2.2.</strong> OS 内核内存、堆栈布局</a></li><li class="chapter-item "><a href="../../os/kern/back-trace.html"><strong aria-hidden="true">1.2.3.</strong> OS backtrace 实现细节</a></li><li class="chapter-item "><a href="../../os/kern/phy-manage.html"><strong aria-hidden="true">1.2.4.</strong> OS 物理页面管理</a></li><li class="chapter-item "><a href="../../os/kern/vir-mem.html"><strong aria-hidden="true">1.2.5.</strong> OS 如何建立虚拟内存映射？</a></li><li class="chapter-item "><a href="../../os/kern/map.html"><strong aria-hidden="true">1.2.6.</strong> OS 内核空间映射细节</a></li></ol></li><li class="chapter-item "><a href="../../os/kern/index.html"><strong aria-hidden="true">1.3.</strong> OS 进程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../os/user/process-mem.html"><strong aria-hidden="true">1.3.1.</strong> OS 进程内部的实现细节</a></li><li class="chapter-item "><a href="../../os/user/process-load.html"><strong aria-hidden="true">1.3.2.</strong> OS 如何将程序加载到虚拟内存中并执行</a></li><li class="chapter-item "><a href="../../os/user/trap-theory.html"><strong aria-hidden="true">1.3.3.</strong> OS 什么是中断和异常？</a></li><li class="chapter-item "><a href="../../os/user/uk-trans.html"><strong aria-hidden="true">1.3.4.</strong> OS 用户态和内核态之间的切换细节</a></li><li class="chapter-item "><a href="../../os/user/trap-impl.html"><strong aria-hidden="true">1.3.5.</strong> OS 中断和异常实现细节</a></li><li class="chapter-item "><a href="../../os/user/page-fault.html"><strong aria-hidden="true">1.3.6.</strong> OS 页面错误实现细节</a></li><li class="chapter-item "><a href="../../os/user/break-point.html"><strong aria-hidden="true">1.3.7.</strong> OS 断点异常实现细节</a></li><li class="chapter-item "><a href="../../os/user/system-call.html"><strong aria-hidden="true">1.3.8.</strong> OS 系统调用实现细节</a></li></ol></li><li class="chapter-item "><a href="../../os/mult/index.html"><strong aria-hidden="true">1.4.</strong> 多核 OS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../os/mult/apic-intro.html"><strong aria-hidden="true">1.4.1.</strong> 多核 OS 初始化细节</a></li><li class="chapter-item "><a href="../../os/mult/ap-init.html"><strong aria-hidden="true">1.4.2.</strong> 多处理器内核栈和环境初始化实现细节</a></li><li class="chapter-item "><a href="../../os/mult/ap-start.html"><strong aria-hidden="true">1.4.3.</strong> 多核 OS AP 启动细节</a></li><li class="chapter-item "><a href="../../os/mult/spin-lock.html"><strong aria-hidden="true">1.4.4.</strong> OS 自旋锁实现细节</a></li><li class="chapter-item "><a href="../../os/mult/round-robin.html"><strong aria-hidden="true">1.4.5.</strong> OS 循环调度实现细节</a></li><li class="chapter-item "><a href="../../os/mult/fork-intro.html"><strong aria-hidden="true">1.4.6.</strong> OS COW Fork 原理图解</a></li><li class="chapter-item "><a href="../../os/mult/cow-fork-pagefalt.html"><strong aria-hidden="true">1.4.7.</strong> COW Fork 页面错误实现细节</a></li><li class="chapter-item "><a href="../../os/mult/cow-fork-init.html"><strong aria-hidden="true">1.4.8.</strong> COW Fork 创建进程实现细节</a></li><li class="chapter-item "><a href="../../os/mult/os-irq.html"><strong aria-hidden="true">1.4.9.</strong> OS 时钟中断实现细节</a></li><li class="chapter-item "><a href="../../os/mult/os-ipc.html"><strong aria-hidden="true">1.4.10.</strong> OS IPC 进程通信实现细节</a></li></ol></li><li class="chapter-item "><a href="../../os/mult/index.html"><strong aria-hidden="true">1.5.</strong> </a></li><li class="chapter-item "><a href="../../os/sleep-lock.html"><strong aria-hidden="true">1.6.</strong> 自旋锁和睡眠锁的区别</a></li><li class="chapter-item "><a href="../../os/shell-know.html"><strong aria-hidden="true">1.7.</strong> Linux 常用命令使用场景</a></li><li class="chapter-item "><a href="../../os/appendix/index.html"><strong aria-hidden="true">1.8.</strong> MIT 6.828 JOS 2018 环境配置</a></li></ol></li><li class="chapter-item expanded "><a href="../../net/index.html"><strong aria-hidden="true">2.</strong> 计算机网络</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../net/tcp/index.html"><strong aria-hidden="true">2.1.</strong> TCP 篇</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../net/tcp/tcp-field.html" class="active"><strong aria-hidden="true">2.1.1.</strong> TCP 报文格式</a></li><li class="chapter-item "><a href="../../net/tcp/pack.html"><strong aria-hidden="true">2.1.2.</strong> TCP 粘包、拆包问题</a></li><li class="chapter-item "><a href="../../net/tcp/tcp-udp.html"><strong aria-hidden="true">2.1.3.</strong> TCP 和 UDP的区别？</a></li><li class="chapter-item "><a href="../../net/tcp/three-hand.html"><strong aria-hidden="true">2.1.4.</strong> TCP 三次握手</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../net/tcp/three-hand-socket.html"><strong aria-hidden="true">2.1.4.1.</strong> Socket 编程中的 TCP 三次握手</a></li></ol></li><li class="chapter-item "><a href="../../net/tcp/timeout-try.html"><strong aria-hidden="true">2.1.5.</strong> TCP 超时重传</a></li><li class="chapter-item "><a href="../../net/tcp/four-hand.html"><strong aria-hidden="true">2.1.6.</strong> TCP 四次挥手</a></li></ol></li><li class="chapter-item "><a href="../../net/ip/index.html"><strong aria-hidden="true">2.2.</strong> IP 篇</a></li><li class="chapter-item "><a href="../../net/http/index.html"><strong aria-hidden="true">2.3.</strong> HTTP 篇</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../net/http/histroy.html"><strong aria-hidden="true">2.3.1.</strong> HTTP 发展历史</a></li><li class="chapter-item "><a href="../../net/http/state.html"><strong aria-hidden="true">2.3.2.</strong> HTTP 状态</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">😈 C++</li><li class="spacer"></li><li class="chapter-item "><a href="../../cpp/basic/index.html"><strong aria-hidden="true">3.</strong> 基础 C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/basic/cpp-iso.html"><strong aria-hidden="true">3.1.</strong> C/C++ 发展历史</a></li><li class="chapter-item "><a href="../../cpp/basic/paradigm.html"><strong aria-hidden="true">3.2.</strong> C++ 编程范式有哪些？</a></li><li class="chapter-item "><a href="../../cpp/basic/base.html"><strong aria-hidden="true">3.3.</strong> 语言基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/basic/pragma-once.html"><strong aria-hidden="true">3.3.1.</strong> pragma-once</a></li><li class="chapter-item "><a href="../../cpp/basic/const-define.html"><strong aria-hidden="true">3.3.2.</strong> const 和 define 的区别？</a></li><li class="chapter-item "><a href="../../cpp/basic/reference.html"><strong aria-hidden="true">3.3.3.</strong> 如何使用引用？</a></li><li class="chapter-item "><a href="../../cpp/basic/ptr-reference.html"><strong aria-hidden="true">3.3.4.</strong> C/C++ 站在汇编的视角看待引用和指针</a></li><li class="chapter-item "><a href="../../cpp/basic/c-asm.html"><strong aria-hidden="true">3.3.5.</strong> C 语言指针编译前后</a></li><li class="chapter-item "><a href="../../cpp/basic/byte-ordering.html"><strong aria-hidden="true">3.3.6.</strong> 大小端</a></li><li class="chapter-item "><a href="../../cpp/basic/constructor.html"><strong aria-hidden="true">3.3.7.</strong> 构造函数</a></li><li class="chapter-item "><a href="../../cpp/basic/null-class.html"><strong aria-hidden="true">3.3.8.</strong> 一个空类默认生成哪些函数？</a></li><li class="chapter-item "><a href="../../cpp/basic/placement-new.html"><strong aria-hidden="true">3.3.9.</strong> new 和 Placement new 的区别</a></li><li class="chapter-item "><a href="../../cpp/basic/delete-new.html"><strong aria-hidden="true">3.3.10.</strong> new 和 malloc 的区别</a></li></ol></li><li class="chapter-item "><a href="../../cpp/basic/cast.html"><strong aria-hidden="true">3.4.</strong> 四种转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/basic/updown-cast.html"><strong aria-hidden="true">3.4.1.</strong> 向上转型、向下转型</a></li><li class="chapter-item "><a href="../../cpp/basic/static-cast.html"><strong aria-hidden="true">3.4.2.</strong> static_cast</a></li><li class="chapter-item "><a href="../../cpp/basic/dynamic-cast.html"><strong aria-hidden="true">3.4.3.</strong> dynamic_cast</a></li><li class="chapter-item "><a href="../../cpp/basic/const-cast.html"><strong aria-hidden="true">3.4.4.</strong> const_cast</a></li><li class="chapter-item "><a href="../../cpp/basic/reinterpret-cast.html"><strong aria-hidden="true">3.4.5.</strong> reinterpret_cast</a></li></ol></li><li class="chapter-item "><a href="../../cpp/basic/base.html"><strong aria-hidden="true">3.5.</strong> 注意事项</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/basic/p1.html"><strong aria-hidden="true">3.5.1.</strong> 如何在代码中提供更明确的语义？</a></li><li class="chapter-item "><a href="../../cpp/basic/p2.html"><strong aria-hidden="true">3.5.2.</strong> C++中的静态类型安全</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../cpp/modern/index.html"><strong aria-hidden="true">4.</strong> 现代 C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/modern/c11/index.html"><strong aria-hidden="true">4.1.</strong> C++11</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/modern/c11/enum-class.html"><strong aria-hidden="true">4.1.1.</strong> enum class</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../cpp/stl/index.html"><strong aria-hidden="true">5.</strong> STL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/stl/allocator.html"><strong aria-hidden="true">5.1.</strong> 空间配置器</a></li><li class="chapter-item "><a href="../../cpp/stl/iterator.html"><strong aria-hidden="true">5.2.</strong> 迭代器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/stl/iter-null.html"><strong aria-hidden="true">5.2.1.</strong> 如何避免迭代器失效</a></li></ol></li><li class="chapter-item "><a href="../../cpp/stl/container.html"><strong aria-hidden="true">5.3.</strong> 容器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/stl/seq-container.html"><strong aria-hidden="true">5.3.1.</strong> 序列容器</a></li><li class="chapter-item "><a href="../../cpp/stl/ass-container.html"><strong aria-hidden="true">5.3.2.</strong> 关联容器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/stl/map.html"><strong aria-hidden="true">5.3.2.1.</strong> map 和 unordered_map 的区别？</a></li></ol></li><li class="chapter-item "><a href="../../cpp/stl/map.html"><strong aria-hidden="true">5.3.3.</strong> 注意</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/stl/container-effective.html"><strong aria-hidden="true">5.3.3.1.</strong> 如何高效的使用 STL 容器？</a></li><li class="chapter-item "><a href="../../cpp/stl/container-how-select.html"><strong aria-hidden="true">5.3.3.2.</strong> STL 如何选择容器？</a></li><li class="chapter-item "><a href="../../cpp/stl/container-null.html"><strong aria-hidden="true">5.3.3.3.</strong> STL 判断长度为空存在哪些坑？</a></li><li class="chapter-item "><a href="../../cpp/stl/resize.html"><strong aria-hidden="true">5.3.3.4.</strong> resize 和 reserve 的区别</a></li><li class="chapter-item "><a href="../../cpp/stl/vector-push-back.html"><strong aria-hidden="true">5.3.3.5.</strong> vector 中 emplace_back 和 push_back 的区别？</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../cpp/stl/map.html"><strong aria-hidden="true">5.4.</strong> 算法</a></li><li class="chapter-item "><a href="../../cpp/stl/map.html"><strong aria-hidden="true">5.5.</strong> 仿函数</a></li><li class="chapter-item "><a href="../../cpp/stl/map.html"><strong aria-hidden="true">5.6.</strong> 其他</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/stl/dll.html"><strong aria-hidden="true">5.6.1.</strong> 容器动态链接可能产生的问题？</a></li><li class="chapter-item "><a href="../../cpp/stl/sec.html"><strong aria-hidden="true">5.6.2.</strong> 容器是否线程安全</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">🤡 源码解析</li><li class="spacer"></li><li class="chapter-item "><a href="../../lsm/0-summary.html"><strong aria-hidden="true">6.</strong> Leveldb 源码阅读</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lsm/read-write.html"><strong aria-hidden="true">6.1.</strong> Leveldb 读写过程</a></li><li class="chapter-item "><a href="../../lsm/memtable.html"><strong aria-hidden="true">6.2.</strong> Leveldb Memtable 读写过程</a></li><li class="chapter-item "><a href="../../lsm/memtable-iter.html"><strong aria-hidden="true">6.3.</strong> Leveldb Memtable 迭代器</a></li><li class="chapter-item "><a href="../../lsm/block.html"><strong aria-hidden="true">6.4.</strong> Leveldb Block 实现细节</a></li><li class="chapter-item "><a href="../../lsm/sst.html"><strong aria-hidden="true">6.5.</strong> Leveldb SST 实现细节</a></li><li class="chapter-item "><a href="../../lsm/bloom-fliter.html"><strong aria-hidden="true">6.6.</strong> Leveldb 布隆过滤器</a></li><li class="chapter-item "><a href="../../lsm/compact-detail.html"><strong aria-hidden="true">6.7.</strong> Leveldb Compaction 总揽</a></li></ol></li><li class="chapter-item "><li class="part-title">🎃 算法</li><li class="spacer"></li><li class="chapter-item "><a href="../../alg/array/index.html"><strong aria-hidden="true">7.</strong> 数组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../alg/array/lc-283.html"><strong aria-hidden="true">7.1.</strong> 283. 移动零</a></li><li class="chapter-item "><a href="../../alg/array/lc-27.html"><strong aria-hidden="true">7.2.</strong> 27. 移除元素</a></li><li class="chapter-item "><a href="../../alg/array/lc-977.html"><strong aria-hidden="true">7.3.</strong> 977. 有序数组的平方</a></li><li class="chapter-item "><a href="../../alg/array/lc-704.html"><strong aria-hidden="true">7.4.</strong> 二分查找</a></li><li class="chapter-item "><a href="../../alg/array/lc-59.html"><strong aria-hidden="true">7.5.</strong> 螺旋矩阵</a></li><li class="chapter-item "><a href="../../alg/array/lc-54.html"><strong aria-hidden="true">7.6.</strong> 螺旋矩阵进阶</a></li></ol></li><li class="chapter-item "><a href="../../alg/linklist/index.html"><strong aria-hidden="true">8.</strong> 链表</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../alg/linklist/lc-203.html"><strong aria-hidden="true">8.1.</strong> 203. 移除链表元素</a></li><li class="chapter-item "><a href="../../alg/linklist/lc-206.html"><strong aria-hidden="true">8.2.</strong> 206. 反转链表</a></li><li class="chapter-item "><a href="../../alg/linklist/lc-24.html"><strong aria-hidden="true">8.3.</strong> 24. 两两交换链表中的节点</a></li><li class="chapter-item "><a href="../../alg/linklist/lc-19.html"><strong aria-hidden="true">8.4.</strong> 19. 删除链表的倒数第 N 个结点</a></li><li class="chapter-item "><a href="../../alg/linklist/lc-02-07.html"><strong aria-hidden="true">8.5.</strong> 面试题 02.07. 链表相交</a></li><li class="chapter-item "><a href="../../alg/linklist/lc-142.html"><strong aria-hidden="true">8.6.</strong> 142. 环形链表 II</a></li><li class="chapter-item "><a href="../../alg/linklist/lc-1206.html"><strong aria-hidden="true">8.7.</strong> 一步一步图解跳表</a></li></ol></li><li class="chapter-item "><a href="../../alg/hash/index.html"><strong aria-hidden="true">9.</strong> 哈希</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../alg/hash/lc-242.html"><strong aria-hidden="true">9.1.</strong> 242. 有效的字母异位词</a></li><li class="chapter-item "><a href="../../alg/hash/lc-1002.html"><strong aria-hidden="true">9.2.</strong> xxxx 1002. 查找共用字符</a></li><li class="chapter-item "><a href="../../alg/hash/lc-349.html"><strong aria-hidden="true">9.3.</strong> 349. 两个数组的交集</a></li></ol></li><li class="chapter-item "><a href="../../alg/tree/index.html"><strong aria-hidden="true">10.</strong> 树</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../alg/tree/trie.html"><strong aria-hidden="true">10.1.</strong> Trie 树</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>
        
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">everystep</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/weijiew/everystep" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/weijiew/everystep/edit/master/src/net/tcp/tcp-field.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="tcp-报文格式"><a class="header" href="#tcp-报文格式">TCP 报文格式</a></h1>
<p>TCP（Transmission Control Protocol，传输控制协议）的数据包由头部和数据部分组成。以下是一个文本图形化的表示方式：</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            TCP Header                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            TCP Data                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li>
<p><strong>TCP Header</strong>：TCP头部，包含了用于控制TCP连接和数据传输的各种信息，如源端口、目标端口、序列号、确认号、窗口大小等。</p>
</li>
<li>
<p><strong>TCP Data</strong>：TCP数据，这是TCP载荷的实际数据，也就是需要传输的信息。</p>
</li>
</ul>
<p>TCP头部的长度通常是20字节，但如果包含了选项字段，长度可能会增加。数据部分的长度则取决于数据包的实际内容。</p>
<h3 id="tcp-头部字段"><a class="header" href="#tcp-头部字段">TCP 头部字段</a></h3>
<p>下面是 TCP（Transmission Control Protocol，传输控制协议）的头部结构：</p>
<pre><code> 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>各字段的含义如下：</p>
<ul>
<li><strong>Source Port</strong>：源端口号，用于标识发送端的应用程序。</li>
<li><strong>Destination Port</strong>：目标端口号，用于标识接收端的应用程序。</li>
<li><strong>Sequence Number</strong>：序列号，用于标识数据包在数据流中的位置。</li>
<li><strong>Acknowledgment Number</strong>：确认号，用于标识期望接收的下一个数据包的序列号。</li>
<li><strong>Data Offset</strong>：数据偏移，标识TCP头部的长度。</li>
<li><strong>Reserved</strong>：保留字段，未使用。</li>
<li><strong>Flags</strong>：标志位，包括URG、ACK、PSH、RST、SYN、FIN等，用于控制TCP的各种行为。</li>
<li><strong>Window</strong>：窗口大小，用于流量控制。</li>
<li><strong>Checksum</strong>：校验和，用于错误检测。</li>
<li><strong>Urgent Pointer</strong>：紧急指针，当URG标志位被设置时使用。</li>
<li><strong>Options</strong>：选项，用于支持一些可选的TCP功能。</li>
<li><strong>Padding</strong>：填充，用于确保TCP头部的长度为32位的整数倍。</li>
<li><strong>Data</strong>：数据，TCP载荷的实际数据。</li>
</ul>
<h3 id="端口"><a class="header" href="#端口">端口</a></h3>
<p>当两台计算机通过TCP进行通信时，它们各自都会有一个源端口和目标端口。这两个端口号是在TCP头部中定义的，用于标识发送端和接收端的应用程序。</p>
<p>例如，假设你的计算机（计算机A）正在尝试通过HTTP协议（它基于TCP）访问一个网站。在这种情况下，计算机A的浏览器会选择一个源端口，例如50000（通常是随机选择的），而目标端口则是80（HTTP协议的标准端口）。</p>
<p>在TCP头部中，这将表示为：</p>
<pre><code>Source Port: 50000
Destination Port: 80
</code></pre>
<p>当网站的服务器收到这个请求时，它会看到源端口是50000，目标端口是80。服务器会处理这个请求，然后发送一个响应回计算机A。在响应的TCP头部中，源端口和目标端口的值会被交换：</p>
<pre><code>Source Port: 80
Destination Port: 50000
</code></pre>
<p>这样，当计算机A收到这个响应时，它就知道这个响应是针对源端口50000的请求的，也就是说，这个响应应该被发送到发起请求的浏览器。</p>
<p>这就是源端口和目标端口在TCP通信中的作用。</p>
<h3 id="序列号"><a class="header" href="#序列号">序列号</a></h3>
<p>在TCP（传输控制协议）中，序列号（Sequence Number）是一个非常重要的概念，它用于标识数据包在数据流中的位置，以确保数据包能够按照正确的顺序被接收和重组。</p>
<p>假设我们有两台计算机，计算机A和计算机B，它们正在通过TCP进行通信。计算机A想要发送一段消息给计算机B，这段消息的内容是"Hello, World!"，但是由于这段消息太长，不能一次性发送，所以它被分割成了两个数据包，分别是"Hello, "和"World!"。</p>
<p>在TCP中，每个数据包都会被赋予一个序列号。假设"Hello, "的序列号是1，"World!"的序列号是2。当计算机B收到这两个数据包时，它会根据序列号的值来确定数据包的顺序，然后将这两个数据包重组成原始的消息"Hello, World!"。</p>
<p>如果没有序列号，那么计算机B可能会收到"World!Hello, "，这显然是错误的。因此，序列号在TCP中起着至关重要的作用。</p>
<p>此外，序列号还用于实现TCP的可靠性。例如，如果计算机B没有收到序列号为2的数据包，它可以通过发送一个特殊的数据包（叫做ACK，Acknowledgment）来告诉计算机A，它需要重新发送序列号为2的数据包。这就是TCP如何确保数据的可靠传输的。</p>
<h3 id="为什么序列号是随机的"><a class="header" href="#为什么序列号是随机的">为什么序列号是随机的？</a></h3>
<p>TCP（传输控制协议）连接的初始化序列号（ISN，Initial Sequence Number）在每次连接建立时都会变化，这是由于以下几个原因：</p>
<ol>
<li>
<p><strong>避免数据混淆</strong>：如果新的连接使用了与旧连接相同的序列号，那么网络中延迟的数据包可能会被错误地认为是新连接的数据包，从而导致数据混淆。</p>
</li>
<li>
<p><strong>安全性</strong>：如果序列号是固定的或者可预测的，那么攻击者可能会利用这个特性进行攻击，例如伪造数据包。通过使每个连接的初始序列号随机，可以增加攻击的难度。</p>
</li>
<li>
<p><strong>流量控制</strong>：序列号也用于TCP的流量控制。每个字节都有一个序列号，接收方通过确认序列号来告诉发送方哪些数据已经被接收。如果序列号不变，那么这个机制将无法正常工作。</p>
</li>
</ol>
<p>因此，每次建立TCP连接时，都会生成一个新的、随机的初始序列号。</p>
<h3 id="acknowledgment-number"><a class="header" href="#acknowledgment-number">Acknowledgment Number</a></h3>
<p>在TCP（传输控制协议）中，Acknowledgment Number（确认号）是一个非常重要的概念，它用于标识接收端期望接收的下一个数据包的序列号，以此来实现TCP的可靠性。</p>
<p>假设我们有两台计算机，计算机A和计算机B，它们正在通过TCP进行通信。计算机A想要发送一段消息给计算机B，这段消息的内容是"Hello, World!"，但是由于这段消息太长，不能一次性发送，所以它被分割成了两个数据包，分别是"Hello, "和"World!"。</p>
<p>在TCP中，每个数据包都会被赋予一个序列号。假设"Hello, "的序列号是1，"World!"的序列号是2。当计算机B收到序列号为1的数据包后，它会发送一个确认号为2的ACK数据包给计算机A，表示它已经成功接收了序列号为1的数据包，期望接收序列号为2的数据包。</p>
<p>如果计算机A没有收到确认号为2的ACK数据包，它会认为序列号为2的数据包在传输过程中丢失，然后重新发送这个数据包。如果计算机A收到了确认号为2的ACK数据包，它就知道序列号为1的数据包已经被成功接收，然后继续发送下一个数据包。</p>
<p>这就是Acknowledgment Number在TCP中的作用。</p>
<h3 id="data-offset"><a class="header" href="#data-offset">Data Offset</a></h3>
<p>在TCP（传输控制协议）中，Data Offset（数据偏移）是一个非常重要的字段，它标识了TCP头部的长度。这个字段的值是以32位（4字节）为单位的，所以如果Data Offset的值是5，那么实际的TCP头部长度就是5*4=20字节。</p>
<p>这个字段的存在是因为TCP头部的长度是可变的。TCP头部有一些可选的字段，比如Options（选项），这些字段可能会被包含在某些数据包的头部中，也可能不被包含。因此，接收端需要通过查看Data Offset的值来确定头部的实际长度，从而知道数据部分从哪里开始。</p>
<p>例如，假设我们有一个TCP数据包，它的Data Offset的值是5，那么接收端就知道头部的长度是20字节，数据部分就从第21字节开始。如果Data Offset的值是6，那么头部的长度就是24字节，数据部分就从第25字节开始。</p>
<p>这就是Data Offset在TCP中的作用。</p>
<h3 id="reserved-字段"><a class="header" href="#reserved-字段">Reserved 字段</a></h3>
<p>在 TCP（传输控制协议）的头部，有一个字段被称为 "Reserved"。这个字段的长度为 6 位，用于未来的扩展。在当前的 TCP 规范中，这个字段必须被设置为 0。</p>
<p>这是 TCP 头部的一部分，其结构如下：</p>
<pre><code class="language-cpp">typedef struct {
    unsigned short source_port;     // 源端口
    unsigned short dest_port;       // 目标端口
    unsigned int sequence_num;      // 序列号
    unsigned int ack_num;           // 确认号
    unsigned char data_offset:4;    // 数据偏移
    unsigned char reserved:6;       // 保留字段
    unsigned char flags;            // 标志字段
    unsigned short window_size;     // 窗口大小
    unsigned short checksum;        // 校验和
    unsigned short urgent_pointer;  // 紧急指针
} tcp_header;
</code></pre>
<p>在这个结构中，<code>reserved</code> 字段被设置为 6 位。这个字段目前没有使用，但是被保留用于未来的扩展。在发送 TCP 包时，这个字段应该被设置为 0。如果接收方收到的 TCP 包中这个字段不为 0，那么这个包应该被忽略。</p>
<p>这是一个简单的例子，展示了如何设置和检查这个字段：</p>
<pre><code class="language-cpp">tcp_header header;
header.reserved = 0; // 设置保留字段为 0

// 检查接收到的 TCP 包的保留字段
if (received_header.reserved != 0) {
    // 忽略这个包
}
</code></pre>
<p>这个例子中，我们首先创建了一个 <code>tcp_header</code> 结构的实例，并将 <code>reserved</code> 字段设置为 0。然后，当我们接收到一个 TCP 包时，我们检查 <code>reserved</code> 字段。如果这个字段不为 0，我们就忽略这个包。</p>
<h3 id="标志位"><a class="header" href="#标志位">标志位</a></h3>
<p>TCP（传输控制协议）的头部中有一个字段被称为 "Flags"。这个字段的长度为 8 位，用于控制 TCP 连接的各种状态。每一位都代表一个特定的标志，包括 URG、ACK、PSH、RST、SYN 和 FIN。</p>
<ul>
<li>URG：紧急指针有效。当这个标志被设置时，表示 TCP 报文段中的紧急指针字段有效，用于告知接收端有紧急数据需要处理。</li>
<li>ACK：确认序号有效。当这个标志被设置时，表示 TCP 报文段中的确认号字段有效，用于告知发送端已经接收到了哪些数据。</li>
<li>PSH：接收方应该尽快将这个报文段交给应用层。当这个标志被设置时，表示 TCP 报文段中的数据应该尽快被接收端的应用层处理，而不是在缓冲区中等待。</li>
<li>RST：重置连接。当这个标志被设置时，表示 TCP 连接出现错误，需要被重置。发送端收到带有 RST 标志的 TCP 报文段后，会立即关闭连接，丢弃缓冲区中的所有数据。</li>
<li>SYN：同步序号，用于建立连接。当这个标志被设置时，表示 TCP 连接正在尝试建立。发送端和接收端会通过交换带有 SYN 标志的 TCP 报文段来同步序号，完成连接的建立。</li>
<li>FIN：结束连接。当这个标志被设置时，表示 TCP 连接正在尝试关闭。发送端和接收端会通过交换带有 FIN 标志的 TCP 报文段来完成连接的关闭。</li>
</ul>
<p>这是一个简单的例子，展示了如何设置和检查这个字段：</p>
<pre><code class="language-cpp">tcp_header header;
header.flags = 0x02; // 设置 SYN 标志

// 检查接收到的 TCP 包的标志字段
if (received_header.flags &amp; 0x01) {
    // 如果 FIN 标志被设置，结束连接
}
</code></pre>
<p>这个例子中，我们首先创建了一个 <code>tcp_header</code> 结构的实例，并将 <code>flags</code> 字段设置为 0x02，表示设置 SYN 标志。然后，当我们接收到一个 TCP 包时，我们检查 <code>flags</code> 字段。如果 FIN 标志被设置（即 flags &amp; 0x01 不为 0），我们就结束连接。</p>
<h3 id="窗口大小"><a class="header" href="#窗口大小">窗口大小</a></h3>
<p>TCP（传输控制协议）的头部中有一个字段被称为 "Window Size"。这个字段的长度为 16 位，用于控制 TCP 连接的流量控制。窗口大小字段表示的是接收方愿意接收的数据量，单位是字节。</p>
<p>在 TCP 连接中，发送方不能无限制地发送数据，而是需要根据接收方的窗口大小来发送。接收方通过窗口大小字段告诉发送方，它还能接收多少数据。发送方在发送数据时，需要确保未被确认的数据量不超过接收方的窗口大小。</p>
<p>这是 TCP 头部的一部分，其结构如下：</p>
<pre><code class="language-cpp">typedef struct {
    unsigned short source_port;     // 源端口
    unsigned short dest_port;       // 目标端口
    unsigned int sequence_num;      // 序列号
    unsigned int ack_num;           // 确认号
    unsigned char data_offset:4;    // 数据偏移
    unsigned char reserved:6;       // 保留字段
    unsigned char flags;            // 标志字段
    unsigned short window_size;     // 窗口大小
    unsigned short checksum;        // 校验和
    unsigned short urgent_pointer;  // 紧急指针
} tcp_header;
</code></pre>
<p>在这个结构中，<code>window_size</code> 字段被设置为 16 位。这个字段表示的是接收方愿意接收的数据量。</p>
<p>这是一个简单的例子，展示了如何设置和检查这个字段：</p>
<pre><code class="language-cpp">tcp_header header;
header.window_size = 1024; // 设置窗口大小为 1024 字节

// 检查接收到的 TCP 包的窗口大小字段
if (received_header.window_size &lt; 1024) {
    // 如果窗口大小小于 1024 字节，减小发送速率
}
</code></pre>
<p>这个例子中，我们首先创建了一个 <code>tcp_header</code> 结构的实例，并将 <code>window_size</code> 字段设置为 1024，表示我们愿意接收的数据量为 1024 字节。然后，当我们接收到一个 TCP 包时，我们检查 <code>window_size</code> 字段。如果窗口大小小于 1024 字节，我们就减小发送速率，以防止发送的数据量超过接收方的处理能力。</p>
<h3 id="校验和"><a class="header" href="#校验和">校验和</a></h3>
<p>TCP（传输控制协议）的头部中有一个字段被称为 "Checksum"。这个字段的长度为 16 位，用于检查 TCP 报文段在传输过程中是否出现错误。校验和字段是通过对整个 TCP 报文段（包括 TCP 头部和数据）进行计算得到的，接收方在接收到 TCP 报文段后，会重新计算校验和，然后与接收到的校验和进行比较，以检查报文段是否在传输过程中出现错误。</p>
<p>这是 TCP 头部的一部分，其结构如下：</p>
<pre><code class="language-cpp">typedef struct {
    unsigned short source_port;     // 源端口
    unsigned short dest_port;       // 目标端口
    unsigned int sequence_num;      // 序列号
    unsigned int ack_num;           // 确认号
    unsigned char data_offset:4;    // 数据偏移
    unsigned char reserved:6;       // 保留字段
    unsigned char flags;            // 标志字段
    unsigned short window_size;     // 窗口大小
    unsigned short checksum;        // 校验和
    unsigned short urgent_pointer;  // 紧急指针
} tcp_header;
</code></pre>
<p>在这个结构中，<code>checksum</code> 字段被设置为 16 位。这个字段是通过对整个 TCP 报文段进行计算得到的。</p>
<p>这是一个简单的例子，展示了如何设置和检查这个字段：</p>
<pre><code class="language-cpp">tcp_header header;
header.checksum = calculate_checksum(&amp;header); // 计算并设置校验和

// 检查接收到的 TCP 包的校验和字段
if (received_header.checksum != calculate_checksum(&amp;received_header)) {
    // 如果校验和不匹配，丢弃这个包
}
</code></pre>
<p>这个例子中，我们首先创建了一个 <code>tcp_header</code> 结构的实例，并通过 <code>calculate_checksum</code> 函数计算并设置 <code>checksum</code> 字段。然后，当我们接收到一个 TCP 包时，我们重新计算校验和，并与接收到的校验和进行比较。如果校验和不匹配，我们就丢弃这个包。</p>
<p>请注意，这个例子中的 <code>calculate_checksum</code> 函数是假设存在的，实际的校验和计算过程会涉及到对 TCP 头部和数据的处理，这个过程比较复杂，超出了这个例子的范围。</p>
<h3 id="紧急指针"><a class="header" href="#紧急指针">紧急指针</a></h3>
<p>TCP（传输控制协议）的头部中有一个字段被称为 "Urgent Pointer"。这个字段的长度为 16 位，只有当 URG 标志位被设置时，这个字段才有效。紧急指针用于指示 TCP 报文段中的紧急数据的结束位置。</p>
<p>当 TCP 连接中的一方需要发送紧急数据时，可以设置 URG 标志，并通过紧急指针字段指示紧急数据的结束位置。接收方在接收到带有 URG 标志的 TCP 报文段后，会优先处理紧急数据。</p>
<p>这是 TCP 头部的一部分，其结构如下：</p>
<pre><code class="language-cpp">typedef struct {
    unsigned short source_port;     // 源端口
    unsigned short dest_port;       // 目标端口
    unsigned int sequence_num;      // 序列号
    unsigned int ack_num;           // 确认号
    unsigned char data_offset:4;    // 数据偏移
    unsigned char reserved:6;       // 保留字段
    unsigned char flags;            // 标志字段
    unsigned short window_size;     // 窗口大小
    unsigned short checksum;        // 校验和
    unsigned short urgent_pointer;  // 紧急指针
} tcp_header;
</code></pre>
<p>在这个结构中，<code>urgent_pointer</code> 字段被设置为 16 位。这个字段用于指示紧急数据的结束位置。</p>
<p>这是一个简单的例子，展示了如何设置和检查这个字段：</p>
<pre><code class="language-cpp">tcp_header header;
header.flags = 0x20; // 设置 URG 标志
header.urgent_pointer = 100; // 设置紧急指针为 100

// 检查接收到的 TCP 包的紧急指针字段
if (received_header.flags &amp; 0x20) {
    // 如果 URG 标志被设置，优先处理前 100 字节的紧急数据
}
</code></pre>
<p>这个例子中，我们首先创建了一个 <code>tcp_header</code> 结构的实例，并将 <code>flags</code> 字段设置为 0x20，表示设置 URG 标志。然后，我们设置 <code>urgent_pointer</code> 字段为 100，表示紧急数据的结束位置为第 100 字节。当我们接收到一个 TCP 包时，我们检查 <code>flags</code> 字段。如果 URG 标志被设置（即 flags &amp; 0x20 不为 0），我们就优先处理前 100 字节的紧急数据。</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>TCP（传输控制协议）的头部中有一个可选字段被称为 "Options"。这个字段的长度可以变化，用于提供 TCP 连接的额外功能。Options 字段可以包含多个选项，每个选项都有一个选项种类和选项长度。常见的 TCP 选项包括最大报文段长度（MSS）、窗口扩大因子（Window Scale）、时间戳（Timestamps）等。</p>
<ul>
<li>
<p>最大报文段长度（MSS）：这个选项用于指定 TCP 报文段的最大长度。发送方在建立连接时，会通过这个选项告诉接收方它能接收的最大报文段长度。接收方在接收到这个选项后，会限制发送的报文段长度不超过这个值。</p>
</li>
<li>
<p>窗口扩大因子（Window Scale）：这个选项用于扩大窗口大小字段的范围。在早期的 TCP 协议中，窗口大小字段的长度为 16 位，最大值为 65535 字节。但随着网络速度的提高，这个值已经不能满足需求。通过窗口扩大因子选项，可以将窗口大小字段的最大值扩大到 1GB。</p>
</li>
<li>
<p>时间戳（Timestamps）：这个选项用于提供更精确的 RTT（往返时间）测量和保护对旧的重复报文段的接收。</p>
</li>
</ul>
<p>这是一个简单的例子，展示了如何设置和检查这个字段：</p>
<pre><code class="language-cpp">typedef struct {
    unsigned char kind; // 选项种类
    unsigned char length; // 选项长度
    unsigned char data[]; // 选项数据
} tcp_option;

typedef struct {
    unsigned short source_port;     // 源端口
    unsigned short dest_port;       // 目标端口
    unsigned int sequence_num;      // 序列号
    unsigned int ack_num;           // 确认号
    unsigned char data_offset:4;    // 数据偏移
    unsigned char reserved:6;       // 保留字段
    unsigned char flags;            // 标志字段
    unsigned short window_size;     // 窗口大小
    unsigned short checksum;        // 校验和
    unsigned short urgent_pointer;  // 紧急指针
    tcp_option options[];           // 选项字段
} tcp_header;

// 创建一个 MSS 选项
tcp_option mss_option;
mss_option.kind = 2; // MSS 选项的种类为 2
mss_option.length = 4; // MSS 选项的长度为 4
*((unsigned short*)mss_option.data) = htons(1460); // MSS 选项的数据为 1460，转换为网络字节序

// 将 MSS 选项添加到 TCP 头部
tcp_header header;
header.options[0] = mss_option;
</code></pre>
<p>这个例子中，我们首先创建了一个 <code>tcp_option</code> 结构的实例，并设置 <code>kind</code> 字段为 2，表示这是一个 MSS 选项。然后，我们设置 <code>length</code> 字段为 4，表示这个选项的长度为 4 字节。最后，我们设置 <code>data</code> 字段为 1460，表示我们能接收的最大报文段长度为 1460 字节。然后，我们将这个选项添加到 TCP 头部的 <code>options</code> 字段。</p>
<p>请注意，这个例子中的 <code>htons</code> 函数用于将主机字节序转换为网络字节序。在实际的网络编程中，我们需要确保所有的网络协议字段都使用网络字节序。</p>
<h3 id="padding"><a class="header" href="#padding">Padding</a></h3>
<p>TCP（传输控制协议）的头部中有一个字段被称为 "Padding"。这个字段的长度可以变化，用于确保 TCP 头部的总长度为 32 位的整数倍。Padding 字段的内容没有实际意义，通常被设置为 0。</p>
<p>在 TCP 协议中，头部的长度必须是 32 位（即 4 字节）的整数倍。这是因为 TCP 协议的设计者选择了 32 位作为基本的对齐单位，以便于在硬件层面上处理 TCP 报文段。但是，由于 Options 字段的长度可以变化，所以 TCP 头部的长度可能不是 32 位的整数倍。在这种情况下，就需要使用 Padding 字段来填充 TCP 头部，使其长度达到 32 位的整数倍。</p>
<p>这是一个简单的例子，展示了如何设置这个字段：</p>
<pre><code class="language-cpp">typedef struct {
    unsigned short source_port;     // 源端口
    unsigned short dest_port;       // 目标端口
    unsigned int sequence_num;      // 序列号
    unsigned int ack_num;           // 确认号
    unsigned char data_offset:4;    // 数据偏移
    unsigned char reserved:6;       // 保留字段
    unsigned char flags;            // 标志字段
    unsigned short window_size;     // 窗口大小
    unsigned short checksum;        // 校验和
    unsigned short urgent_pointer;  // 紧急指针
    unsigned char options_and_padding[40]; // 选项和填充字段
} tcp_header;

// 创建一个 TCP 头部
tcp_header header;
memset(&amp;header, 0, sizeof(header)); // 将整个头部初始化为 0

// 设置选项
header.options_and_padding[0] = 0x02; // 设置 MSS 选项的种类
header.options_and_padding[1] = 0x04; // 设置 MSS 选项的长度
*((unsigned short*)&amp;header.options_and_padding[2]) = htons(1460); // 设置 MSS 选项的数据

// 剩余的部分会作为 Padding 字段，已经被初始化为 0
</code></pre>
<p>这个例子中，我们首先创建了一个 <code>tcp_header</code> 结构的实例，并将整个头部初始化为 0。然后，我们在 <code>options_and_padding</code> 字段中设置 MSS 选项。剩余的部分会作为 Padding 字段，已经被初始化为 0，所以我们不需要再进行任何操作。</p>
<h3 id="data"><a class="header" href="#data">Data</a></h3>
<p>TCP（传输控制协议）的头部后面跟随的是 "Data" 字段。这个字段的长度可以变化，用于携带 TCP 连接中传输的实际数据。Data 字段的内容由应用程序决定，TCP 协议本身并不关心其内容。</p>
<p>在 TCP 连接中，发送方和接收方会交换数据。发送方将要发送的数据放入 Data 字段，然后将 TCP 报文段发送给接收方。接收方在接收到 TCP 报文段后，会从 Data 字段中取出数据，然后将其交给应用程序。</p>
<p>这是一个简单的例子，展示了如何设置和检查这个字段：</p>
<pre><code class="language-cpp">typedef struct {
    unsigned short source_port;     // 源端口
    unsigned short dest_port;       // 目标端口
    unsigned int sequence_num;      // 序列号
    unsigned int ack_num;           // 确认号
    unsigned char data_offset:4;    // 数据偏移
    unsigned char reserved:6;       // 保留字段
    unsigned char flags;            // 标志字段
    unsigned short window_size;     // 窗口大小
    unsigned short checksum;        // 校验和
    unsigned short urgent_pointer;  // 紧急指针
    unsigned char options_and_padding[40]; // 选项和填充字段
    char data[];                    // 数据字段
} tcp_header;

// 创建一个 TCP 头部
tcp_header* header = (tcp_header*)malloc(sizeof(tcp_header) + 1024); // 分配足够的空间来存储数据

// 设置数据
strcpy(header-&gt;data, "Hello, world!"); // 将 "Hello, world!" 复制到数据字段
</code></pre>
<p>这个例子中，我们首先创建了一个 <code>tcp_header</code> 结构的实例，并分配了足够的空间来存储数据。然后，我们将 "Hello, world!" 复制到数据字段。</p>
<p>请注意，这个例子中的 <code>malloc</code> 函数用于动态分配内存。在实际的网络编程中，我们需要根据实际的数据大小来动态分配内存。</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../net/tcp/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../net/tcp/pack.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../net/tcp/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../net/tcp/pack.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <script type="text/javascript" charset="utf-8">
        var pagePath = "net/tcp/tcp-field.md"
        </script>


        <!-- Custom JS scripts -->
        <script src="../../assets/custom.js"></script>
        <script src="../../assets/bigPicture.js"></script>


    </div>
    </body>
</html>