<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Leveldb Compaction 总揽 - everystep</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../about-book.html">关于项目</a></li><li class="chapter-item affix "><li class="part-title">🌟 计算机基础</li><li class="spacer"></li><li class="chapter-item "><a href="../os/0-summary.html"><strong aria-hidden="true">1.</strong> 操作系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../os/start/index.html"><strong aria-hidden="true">1.1.</strong> OS 启动过程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../os/start/bios.html"><strong aria-hidden="true">1.1.1.</strong> OS 启动之 BIOS</a></li><li class="chapter-item "><a href="../os/start/boot-loader.html"><strong aria-hidden="true">1.1.2.</strong> OS 启动 Boot Loader 汇编实现细节</a></li><li class="chapter-item "><a href="../os/start/boot-main.html"><strong aria-hidden="true">1.1.3.</strong> OS 启动 Boot Loader C语言实现细节</a></li><li class="chapter-item "><a href="../os/start/pc-address.html"><strong aria-hidden="true">1.1.4.</strong> OS 内存地址空间的演化历程</a></li><li class="chapter-item "><a href="../os/start/real-mold.html"><strong aria-hidden="true">1.1.5.</strong> OS 实模式、保护模式</a></li><li class="chapter-item "><a href="../os/start/seg-page.html"><strong aria-hidden="true">1.1.6.</strong> OS 分段、分页</a></li></ol></li><li class="chapter-item "><a href="../os/kern/index.html"><strong aria-hidden="true">1.2.</strong> OS 内核</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../os/kern/os-asm.html"><strong aria-hidden="true">1.2.1.</strong> OS 内核入口实现细节</a></li><li class="chapter-item "><a href="../os/kern/os-stack.html"><strong aria-hidden="true">1.2.2.</strong> OS 内核内存、堆栈布局</a></li><li class="chapter-item "><a href="../os/kern/back-trace.html"><strong aria-hidden="true">1.2.3.</strong> OS backtrace 实现细节</a></li><li class="chapter-item "><a href="../os/kern/phy-manage.html"><strong aria-hidden="true">1.2.4.</strong> OS 物理页面管理</a></li><li class="chapter-item "><a href="../os/kern/vir-mem.html"><strong aria-hidden="true">1.2.5.</strong> OS 如何建立虚拟内存映射？</a></li><li class="chapter-item "><a href="../os/kern/map.html"><strong aria-hidden="true">1.2.6.</strong> OS 内核空间映射细节</a></li></ol></li><li class="chapter-item "><a href="../os/kern/index.html"><strong aria-hidden="true">1.3.</strong> OS 进程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../os/user/process-mem.html"><strong aria-hidden="true">1.3.1.</strong> OS 进程内部的实现细节</a></li><li class="chapter-item "><a href="../os/user/process-load.html"><strong aria-hidden="true">1.3.2.</strong> OS 如何将程序加载到虚拟内存中并执行</a></li><li class="chapter-item "><a href="../os/user/trap-theory.html"><strong aria-hidden="true">1.3.3.</strong> OS 什么是中断和异常？</a></li><li class="chapter-item "><a href="../os/user/uk-trans.html"><strong aria-hidden="true">1.3.4.</strong> OS 用户态和内核态之间的切换细节</a></li><li class="chapter-item "><a href="../os/user/trap-impl.html"><strong aria-hidden="true">1.3.5.</strong> OS 中断和异常实现细节</a></li><li class="chapter-item "><a href="../os/user/page-fault.html"><strong aria-hidden="true">1.3.6.</strong> OS 页面错误实现细节</a></li><li class="chapter-item "><a href="../os/user/break-point.html"><strong aria-hidden="true">1.3.7.</strong> OS 断点异常实现细节</a></li><li class="chapter-item "><a href="../os/user/system-call.html"><strong aria-hidden="true">1.3.8.</strong> OS 系统调用实现细节</a></li></ol></li><li class="chapter-item "><a href="../os/mult/index.html"><strong aria-hidden="true">1.4.</strong> 多核 OS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../os/mult/apic-intro.html"><strong aria-hidden="true">1.4.1.</strong> 多核 OS 初始化细节</a></li><li class="chapter-item "><a href="../os/mult/ap-init.html"><strong aria-hidden="true">1.4.2.</strong> 多处理器内核栈和环境初始化实现细节</a></li><li class="chapter-item "><a href="../os/mult/ap-start.html"><strong aria-hidden="true">1.4.3.</strong> 多核 OS AP 启动细节</a></li><li class="chapter-item "><a href="../os/mult/spin-lock.html"><strong aria-hidden="true">1.4.4.</strong> OS 自旋锁实现细节</a></li><li class="chapter-item "><a href="../os/mult/round-robin.html"><strong aria-hidden="true">1.4.5.</strong> OS 循环调度实现细节</a></li><li class="chapter-item "><a href="../os/mult/fork-intro.html"><strong aria-hidden="true">1.4.6.</strong> OS COW Fork 原理图解</a></li><li class="chapter-item "><a href="../os/mult/cow-fork-pagefalt.html"><strong aria-hidden="true">1.4.7.</strong> COW Fork 页面错误实现细节</a></li><li class="chapter-item "><a href="../os/mult/cow-fork-init.html"><strong aria-hidden="true">1.4.8.</strong> COW Fork 创建进程实现细节</a></li><li class="chapter-item "><a href="../os/mult/os-irq.html"><strong aria-hidden="true">1.4.9.</strong> OS 时钟中断实现细节</a></li><li class="chapter-item "><a href="../os/mult/os-ipc.html"><strong aria-hidden="true">1.4.10.</strong> OS IPC 进程通信实现细节</a></li></ol></li><li class="chapter-item "><a href="../os/mult/index.html"><strong aria-hidden="true">1.5.</strong> </a></li><li class="chapter-item "><a href="../os/sleep-lock.html"><strong aria-hidden="true">1.6.</strong> 自旋锁和睡眠锁的区别</a></li><li class="chapter-item "><a href="../os/shell-know.html"><strong aria-hidden="true">1.7.</strong> Linux 常用命令使用场景</a></li><li class="chapter-item "><a href="../os/appendix/index.html"><strong aria-hidden="true">1.8.</strong> MIT 6.828 JOS 2018 环境配置</a></li></ol></li><li class="chapter-item "><a href="../net/index.html"><strong aria-hidden="true">2.</strong> 计算机网络</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../net/tcp/index.html"><strong aria-hidden="true">2.1.</strong> TCP 篇</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../net/tcp/tcp-field.html"><strong aria-hidden="true">2.1.1.</strong> TCP 报文格式</a></li><li class="chapter-item "><a href="../net/tcp/pack.html"><strong aria-hidden="true">2.1.2.</strong> TCP 粘包、拆包问题</a></li><li class="chapter-item "><a href="../net/tcp/tcp-udp.html"><strong aria-hidden="true">2.1.3.</strong> TCP 和 UDP的区别？</a></li><li class="chapter-item "><a href="../net/tcp/three-hand.html"><strong aria-hidden="true">2.1.4.</strong> TCP 三次握手</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../net/tcp/three-hand-socket.html"><strong aria-hidden="true">2.1.4.1.</strong> Socket 编程中的 TCP 三次握手</a></li></ol></li><li class="chapter-item "><a href="../net/tcp/timeout-try.html"><strong aria-hidden="true">2.1.5.</strong> TCP 超时重传</a></li><li class="chapter-item "><a href="../net/tcp/four-hand.html"><strong aria-hidden="true">2.1.6.</strong> TCP 四次挥手</a></li></ol></li><li class="chapter-item "><a href="../net/ip/index.html"><strong aria-hidden="true">2.2.</strong> IP 篇</a></li><li class="chapter-item "><a href="../net/http/index.html"><strong aria-hidden="true">2.3.</strong> HTTP 篇</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../net/http/histroy.html"><strong aria-hidden="true">2.3.1.</strong> HTTP 发展历史</a></li><li class="chapter-item "><a href="../net/http/state.html"><strong aria-hidden="true">2.3.2.</strong> HTTP 状态</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">😈 C++</li><li class="spacer"></li><li class="chapter-item "><a href="../cpp/basic/index.html"><strong aria-hidden="true">3.</strong> 基础 C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/basic/cpp-iso.html"><strong aria-hidden="true">3.1.</strong> C/C++ 发展历史</a></li><li class="chapter-item "><a href="../cpp/basic/paradigm.html"><strong aria-hidden="true">3.2.</strong> C++ 编程范式有哪些？</a></li><li class="chapter-item "><a href="../cpp/basic/base.html"><strong aria-hidden="true">3.3.</strong> 语言基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/basic/pragma-once.html"><strong aria-hidden="true">3.3.1.</strong> pragma-once</a></li><li class="chapter-item "><a href="../cpp/basic/const-define.html"><strong aria-hidden="true">3.3.2.</strong> const 和 define 的区别？</a></li><li class="chapter-item "><a href="../cpp/basic/reference.html"><strong aria-hidden="true">3.3.3.</strong> 如何使用引用？</a></li><li class="chapter-item "><a href="../cpp/basic/ptr-reference.html"><strong aria-hidden="true">3.3.4.</strong> C/C++ 站在汇编的视角看待引用和指针</a></li><li class="chapter-item "><a href="../cpp/basic/c-asm.html"><strong aria-hidden="true">3.3.5.</strong> C 语言指针编译前后</a></li><li class="chapter-item "><a href="../cpp/basic/byte-ordering.html"><strong aria-hidden="true">3.3.6.</strong> 大小端</a></li><li class="chapter-item "><a href="../cpp/basic/constructor.html"><strong aria-hidden="true">3.3.7.</strong> 构造函数</a></li><li class="chapter-item "><a href="../cpp/basic/null-class.html"><strong aria-hidden="true">3.3.8.</strong> 一个空类默认生成哪些函数？</a></li><li class="chapter-item "><a href="../cpp/basic/placement-new.html"><strong aria-hidden="true">3.3.9.</strong> new 和 Placement new 的区别</a></li><li class="chapter-item "><a href="../cpp/basic/delete-new.html"><strong aria-hidden="true">3.3.10.</strong> new 和 malloc 的区别</a></li></ol></li><li class="chapter-item "><a href="../cpp/basic/cast.html"><strong aria-hidden="true">3.4.</strong> 四种转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/basic/updown-cast.html"><strong aria-hidden="true">3.4.1.</strong> 向上转型、向下转型</a></li><li class="chapter-item "><a href="../cpp/basic/static-cast.html"><strong aria-hidden="true">3.4.2.</strong> static_cast</a></li><li class="chapter-item "><a href="../cpp/basic/dynamic-cast.html"><strong aria-hidden="true">3.4.3.</strong> dynamic_cast</a></li><li class="chapter-item "><a href="../cpp/basic/const-cast.html"><strong aria-hidden="true">3.4.4.</strong> const_cast</a></li><li class="chapter-item "><a href="../cpp/basic/reinterpret-cast.html"><strong aria-hidden="true">3.4.5.</strong> reinterpret_cast</a></li></ol></li><li class="chapter-item "><a href="../cpp/basic/base.html"><strong aria-hidden="true">3.5.</strong> 注意事项</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/basic/p1.html"><strong aria-hidden="true">3.5.1.</strong> 如何在代码中提供更明确的语义？</a></li><li class="chapter-item "><a href="../cpp/basic/p2.html"><strong aria-hidden="true">3.5.2.</strong> C++中的静态类型安全</a></li></ol></li></ol></li><li class="chapter-item "><a href="../cpp/modern/index.html"><strong aria-hidden="true">4.</strong> 现代 C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/modern/c11/index.html"><strong aria-hidden="true">4.1.</strong> C++11</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/modern/c11/enum-class.html"><strong aria-hidden="true">4.1.1.</strong> enum class</a></li></ol></li></ol></li><li class="chapter-item "><a href="../cpp/stl/index.html"><strong aria-hidden="true">5.</strong> STL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/stl/allocator.html"><strong aria-hidden="true">5.1.</strong> 空间配置器</a></li><li class="chapter-item "><a href="../cpp/stl/iterator.html"><strong aria-hidden="true">5.2.</strong> 迭代器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/stl/iter-null.html"><strong aria-hidden="true">5.2.1.</strong> 如何避免迭代器失效</a></li></ol></li><li class="chapter-item "><a href="../cpp/stl/container.html"><strong aria-hidden="true">5.3.</strong> 容器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/stl/seq-container.html"><strong aria-hidden="true">5.3.1.</strong> 序列容器</a></li><li class="chapter-item "><a href="../cpp/stl/ass-container.html"><strong aria-hidden="true">5.3.2.</strong> 关联容器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/stl/map.html"><strong aria-hidden="true">5.3.2.1.</strong> map 和 unordered_map 的区别？</a></li></ol></li><li class="chapter-item "><a href="../cpp/stl/map.html"><strong aria-hidden="true">5.3.3.</strong> 注意</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/stl/container-effective.html"><strong aria-hidden="true">5.3.3.1.</strong> 如何高效的使用 STL 容器？</a></li><li class="chapter-item "><a href="../cpp/stl/container-how-select.html"><strong aria-hidden="true">5.3.3.2.</strong> STL 如何选择容器？</a></li><li class="chapter-item "><a href="../cpp/stl/container-null.html"><strong aria-hidden="true">5.3.3.3.</strong> STL 判断长度为空存在哪些坑？</a></li><li class="chapter-item "><a href="../cpp/stl/resize.html"><strong aria-hidden="true">5.3.3.4.</strong> resize 和 reserve 的区别</a></li><li class="chapter-item "><a href="../cpp/stl/vector-push-back.html"><strong aria-hidden="true">5.3.3.5.</strong> vector 中 emplace_back 和 push_back 的区别？</a></li></ol></li></ol></li><li class="chapter-item "><a href="../cpp/stl/map.html"><strong aria-hidden="true">5.4.</strong> 算法</a></li><li class="chapter-item "><a href="../cpp/stl/map.html"><strong aria-hidden="true">5.5.</strong> 仿函数</a></li><li class="chapter-item "><a href="../cpp/stl/map.html"><strong aria-hidden="true">5.6.</strong> 其他</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cpp/stl/dll.html"><strong aria-hidden="true">5.6.1.</strong> 容器动态链接可能产生的问题？</a></li><li class="chapter-item "><a href="../cpp/stl/sec.html"><strong aria-hidden="true">5.6.2.</strong> 容器是否线程安全</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">🤡 源码解析</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../lsm/0-summary.html"><strong aria-hidden="true">6.</strong> Leveldb 源码阅读</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../lsm/read-write.html"><strong aria-hidden="true">6.1.</strong> Leveldb 读写过程</a></li><li class="chapter-item "><a href="../lsm/memtable.html"><strong aria-hidden="true">6.2.</strong> Leveldb Memtable 读写过程</a></li><li class="chapter-item "><a href="../lsm/memtable-iter.html"><strong aria-hidden="true">6.3.</strong> Leveldb Memtable 迭代器</a></li><li class="chapter-item "><a href="../lsm/block.html"><strong aria-hidden="true">6.4.</strong> Leveldb Block 实现细节</a></li><li class="chapter-item "><a href="../lsm/sst.html"><strong aria-hidden="true">6.5.</strong> Leveldb SST 实现细节</a></li><li class="chapter-item "><a href="../lsm/bloom-fliter.html"><strong aria-hidden="true">6.6.</strong> Leveldb 布隆过滤器</a></li><li class="chapter-item expanded "><a href="../lsm/compact-detail.html" class="active"><strong aria-hidden="true">6.7.</strong> Leveldb Compaction 总揽</a></li></ol></li><li class="chapter-item "><li class="part-title">🎃 算法</li><li class="spacer"></li><li class="chapter-item "><a href="../alg/array/index.html"><strong aria-hidden="true">7.</strong> 数组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../alg/array/lc-283.html"><strong aria-hidden="true">7.1.</strong> 283. 移动零</a></li><li class="chapter-item "><a href="../alg/array/lc-27.html"><strong aria-hidden="true">7.2.</strong> 27. 移除元素</a></li><li class="chapter-item "><a href="../alg/array/lc-977.html"><strong aria-hidden="true">7.3.</strong> 977. 有序数组的平方</a></li><li class="chapter-item "><a href="../alg/array/lc-704.html"><strong aria-hidden="true">7.4.</strong> 二分查找</a></li><li class="chapter-item "><a href="../alg/array/lc-59.html"><strong aria-hidden="true">7.5.</strong> 螺旋矩阵</a></li><li class="chapter-item "><a href="../alg/array/lc-54.html"><strong aria-hidden="true">7.6.</strong> 螺旋矩阵进阶</a></li></ol></li><li class="chapter-item "><a href="../alg/linklist/index.html"><strong aria-hidden="true">8.</strong> 链表</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../alg/linklist/lc-203.html"><strong aria-hidden="true">8.1.</strong> 203. 移除链表元素</a></li><li class="chapter-item "><a href="../alg/linklist/lc-206.html"><strong aria-hidden="true">8.2.</strong> 206. 反转链表</a></li><li class="chapter-item "><a href="../alg/linklist/lc-24.html"><strong aria-hidden="true">8.3.</strong> 24. 两两交换链表中的节点</a></li><li class="chapter-item "><a href="../alg/linklist/lc-19.html"><strong aria-hidden="true">8.4.</strong> 19. 删除链表的倒数第 N 个结点</a></li><li class="chapter-item "><a href="../alg/linklist/lc-02-07.html"><strong aria-hidden="true">8.5.</strong> 面试题 02.07. 链表相交</a></li><li class="chapter-item "><a href="../alg/linklist/lc-142.html"><strong aria-hidden="true">8.6.</strong> 142. 环形链表 II</a></li><li class="chapter-item "><a href="../alg/linklist/lc-1206.html"><strong aria-hidden="true">8.7.</strong> 一步一步图解跳表</a></li></ol></li><li class="chapter-item "><a href="../alg/hash/index.html"><strong aria-hidden="true">9.</strong> 哈希</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../alg/hash/lc-242.html"><strong aria-hidden="true">9.1.</strong> 242. 有效的字母异位词</a></li><li class="chapter-item "><a href="../alg/hash/lc-1002.html"><strong aria-hidden="true">9.2.</strong> xxxx 1002. 查找共用字符</a></li><li class="chapter-item "><a href="../alg/hash/lc-349.html"><strong aria-hidden="true">9.3.</strong> 349. 两个数组的交集</a></li></ol></li><li class="chapter-item "><a href="../alg/tree/index.html"><strong aria-hidden="true">10.</strong> 树</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../alg/tree/trie.html"><strong aria-hidden="true">10.1.</strong> Trie 树</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>
        
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">everystep</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/weijiew/everystep" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/weijiew/everystep/edit/master/src/lsm/compact-detail.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <p>在 LevelDB 中，合并（Compaction）是一种重要的操作，用于优化存储空间和提高查询性能。它的主要目的是减少读放大（Read Amplification）并提高查询效率。</p>
<h3 id="什么是合并"><a class="header" href="#什么是合并">什么是合并？</a></h3>
<p>合并操作主要包括两种：Minor Compaction 和 Major Compaction。当内存中的 MemTable 达到一定大小时，它会被转换为 SST 文件并刷新（Flush）到磁盘。这个过程称为 Minor Compaction。</p>
<p>在 LevelDB 中，Major Compaction 会涉及到两个层级的 SST 文件的合并。当一个层级的 SST 文件数量或大小达到一定阈值时，LevelDB 会选择一些 SST 文件，并将这些 SST 文件与下一层级的一些 SST 文件合并，生成新的 SST 文件。这些新的 SST 文件会被存储在下一层级中。</p>
<p>例如，当 Level 0 的 SST 文件数量达到一定数量（默认为 4）时，LevelDB 会触发一次 Major Compaction，将 Level 0 的 SST 文件和 Level 1 的 SST 文件合并，并生成新的 SST 文件。这些新的 SST 文件被存储在 Level 1 中。</p>
<p>同样，当 Level 1 的 SST 文件大小达到 10MB（默认值）时，LevelDB 会触发一次 Major Compaction，将 Level 1 的 SST 文件和 Level 2 的 SST 文件合并，并生成新的 SST 文件。这些新的 SST 文件被存储在 Level 2 中。</p>
<p>对于 Level 3 及以上，也是同样的处理方式。每次 Major Compaction 都会涉及到两个层级的 SST 文件的合并，生成的新的 SST 文件会被存储在下一层级中。</p>
<p>在合并过程中，LevelDB 会选择一些 SST 文件，将这些文件中的数据项进行排序并合并，然后分割成多个新的 SST 文件。这个过程中，原来的数据会被重新写入磁盘，从而导致写放大（Write Amplification）。但是，合并操作可以减少 SST 文件的数量，从而减少读放大和空间放大。</p>
<h3 id="minor-compaction-实现细节"><a class="header" href="#minor-compaction-实现细节">Minor Compaction 实现细节</a></h3>
<p>Minor Compaction：当内存中的 MemTable 达到一定大小时，它会被转换为 SST 文件并刷新到磁盘。这个过程称为 Minor Compaction。Minor Compaction 主要发生在 Level 0，主要涉及到最新的 SST 文件，因此产生的额外磁盘 I/O 较少。</p>
<p>在 LevelDB 中，Minor Compaction 主要发生在 MemTable 达到一定大小时。这个过程主要涉及到最新的 SST 文件，因此产生的额外磁盘 I/O 较少。</p>
<p>具体来说，当 MemTable 达到一定大小时，LevelDB 会创建一个新的 SST 文件，并将 MemTable 中的数据写入到这个 SST 文件中。在这个过程中，LevelDB 会使用 <code>BlockBuilder</code> 类来构建 SST 文件中的 block。</p>
<p>这个过程主要涉及到 <code>Add</code> 和 <code>Finish</code> 两个方法。</p>
<ol>
<li>
<p><code>Add</code> 方法：这个方法用于将一个键值对添加到 block 中。它首先检查是否需要添加一个 "restart point"。Restart points 是用于在 block 中进行二分查找的关键点，它们的存在可以提高查找速度。如果当前的键值对是第一个，或者与上一个键值对的共享前缀长度小于某个阈值，那么就会在 <code>restarts_</code> 数组中添加当前 block 的偏移量，作为一个新的 restart point。然后，<code>Add</code> 方法会将键值对的共享前缀长度、非共享前缀长度和值长度，以及非共享的键的部分和值，依次写入到 <code>buffer_</code> 中。</p>
</li>
<li>
<p><code>Finish</code> 方法：这个方法用于完成 block 的构建。它首先将所有的 restart points 写入到 <code>buffer_</code> 的末尾，然后将 restart points 的数量写入到 <code>buffer_</code> 的末尾。最后，它返回一个 <code>Slice</code>，这个 <code>Slice</code> 引用了 <code>buffer_</code> 中的数据，代表了构建完成的 block。</p>
</li>
</ol>
<p>在将 MemTable 中的数据写入到 SST 文件中时，LevelDB 会创建一个 <code>BlockBuilder</code> 对象，然后遍历 MemTable 中的所有键值对，使用 <code>Add</code> 方法将它们添加到 <code>BlockBuilder</code> 中。当所有的键值对都添加完毕后，调用 <code>Finish</code> 方法完成 block 的构建，然后将构建完成的 block 写入到 SST 文件中。</p>
<p>每个 block 中的数据都是按照 key 的顺序存储的，而且每个 key 都会进行前缀合并，也就是说，每个 key 只保存与前一个 key 的差异部分。但是，为了能够快速定位到任意一个 key，LevelDB 会在每个 block 中设置一些 restart points，每个 restart point 的位置都会保存一个完整的 key。</p>
<p>在 <code>BlockBuilder::Finish()</code> 方法中，LevelDB 会将所有的 restart points 的信息写入到 buffer 中，然后将 buffer 写入到 SST 文件中。这个过程就是 Minor Compaction 的一部分。</p>
<p>总的来说，Minor Compaction 是 LevelDB 中的一个重要操作，它可以有效地将内存中的数据刷新到磁盘，同时通过使用前缀合并和设置 restart points 来优化读取性能。</p>
<h3 id="major-compaction-实现细节"><a class="header" href="#major-compaction-实现细节">Major Compaction 实现细节</a></h3>
<p>Major Compaction：Major Compaction 是指将多个 SST 文件合并为一个新的 SST 文件，同时删除重复的键和过期的数据。这个过程会产生大量的额外磁盘 I/O，从而导致写放大。Major Compaction 涉及到所有的 SST 文件，它会读取所有的数据并重新写入磁盘。</p>
<p>在 LevelDB 的源代码中，合并操作是在 <code>db/db_impl.cc</code> 文件的 <code>DBImpl::CompactRange</code> 方法中实现的。这个方法会创建一个 <code>Compaction</code> 对象，然后调用 <code>DBImpl::DoCompactionWork</code> 方法来执行实际的合并操作。</p>
<p>在 <code>DBImpl::DoCompactionWork</code> 方法中，它会创建一个 <code>CompactionState</code> 对象来保存合并操作的状态，然后通过循环调用 <code>Compaction::Next</code> 方法来逐步进行合并操作。在每次循环中，它会调用 <code>Compaction::Next</code> 方法来获取下一个要合并的键值对，然后调用 <code>CompactionState::Add</code> 方法将这个键值对添加到新的 SST 文件中。</p>
<p>在 <code>CompactionState::Add</code> 方法中，它会检查当前的键是否与上一个键相同，如果相同，则表示这是一个重复的键，它会被忽略。如果当前的键是一个删除标记，则表示这是一个过期的数据，它也会被忽略。只有当当前的键既不是重复的键，也不是删除标记时，它才会被添加到新的 SST 文件中。</p>
<p>在合并操作完成后，<code>DBImpl::DoCompactionWork</code> 方法会调用 <code>CompactionState::Finish</code> 方法来关闭新的 SST 文件，并将其添加到 SST 文件的列表中。然后，它会调用 <code>VersionSet::LogAndApply</code> 方法来更新元数据，并将新的 SST 文件添加到 LSM 树中。最后，它会删除旧的 SST 文件，并释放相关的资源。</p>
<p>以上就是 LevelDB 中合并操作的基本流程。</p>
<h3 id="leveldb-如何处理与合并并行的-l0-刷新"><a class="header" href="#leveldb-如何处理与合并并行的-l0-刷新">Leveldb 如何处理与合并并行的 L0 刷新？</a></h3>
<p>LevelDB 的 L0 层刷新和合并操作主要在 <code>db_impl.cc</code> 文件中的 <code>DBImpl::CompactMemTable</code> 和 <code>DBImpl::BackgroundCompaction</code> 函数中进行。</p>
<p>首先，当内存表（MemTable）满了，或者用户手动触发了刷新操作，LevelDB 会将 MemTable 的内容写入到磁盘，形成一个新的 SST 文件，这个过程就是 L0 刷新。这个新的 SST 文件会被添加到 VersionSet 中，成为 L0 层的一部分。</p>
<p>然后，如果 L0 层的文件数量超过了一定的阈值（默认是 4），LevelDB 就会触发 L0 到 L1 的合并操作。这个过程是在 <code>DBImpl::BackgroundCompaction</code> 函数中进行的。在这个函数中，LevelDB 会选择一个合适的 L0 文件和 L1 文件，然后将这两个文件进行合并，合并的结果会生成新的 SST 文件，这些新的 SST 文件会被添加到 L1 层。</p>
<p>在这个过程中，LevelDB 会尽量避免获取全局的状态锁。具体来说，LevelDB 在进行 L0 刷新和合并操作时，会先获取状态锁，然后更新 VersionSet，添加新的 SST 文件，最后释放状态锁。这样，即使在进行 L0 刷新和合并操作的过程中有新的 L0 文件产生，也不会影响到正在进行的操作，因为新的 L0 文件会被添加到下一次的合并操作中。</p>
<p>这就是 LevelDB 如何处理和合并并行的 L0 刷新的大致过程。具体的实现细节可能会因为 LevelDB 的版本和配置的不同而有所不同。</p>
<h3 id="合并后立即删除原始-sst-文件会有问题吗"><a class="header" href="#合并后立即删除原始-sst-文件会有问题吗">合并后立即删除原始 SST 文件会有问题吗？</a></h3>
<p>在 LevelDB 中，合并完成后立即删除原始 SST 文件通常不会在系统中引起问题。这是因为 LevelDB 使用了一种称为“延迟删除”的策略。</p>
<p>在这种策略中，当 LevelDB 决定删除一个 SST 文件时，它并不会立即删除这个文件。相反，它会将这个文件的文件名添加到一个待删除文件列表中。然后，在后台清理线程中，LevelDB 会定期检查这个待删除文件列表，如果列表中的文件没有被数据库的任何部分引用，那么这个文件就会被实际删除。</p>
<p>这种策略的好处是，即使在 LevelDB 合并完成后立即删除原始 SST 文件，也不会影响到正在使用这个文件的读操作。因为只有当文件没有被任何部分引用时，文件才会被实际删除。</p>
<p>这种策略在 macOS 和 Linux 上工作得很好，因为这两个操作系统都支持“删除打开文件”。也就是说，即使一个文件被删除了，只要还有一个文件句柄在引用这个文件，那么这个文件的内容就仍然可以被访问。只有当最后一个文件句柄被关闭时，文件才会被实际删除。</p>
<p>具体到代码层面，LevelDB 的这种延迟删除策略主要在 <code>db_impl.cc</code> 文件的 <code>DBImpl::DeleteObsoleteFiles</code> 函数中实现。这个函数会遍历待删除文件列表，对于每个文件，它会检查这个文件是否被数据库的任何部分引用，如果没有，那么这个文件就会被实际删除。</p>
<p>但是在 windows 上不能直接删除打开的文件，直接删除会返回一个错误。所以当删除时会线检查该文件是否正在被使用，如果不被使用时才会删除。这种策略可以确保删除操作不会影响到正在进行的读操作。</p>
<p>这种策略的实现主要在 <code>env_windows.cc</code> 文件的 <code>Win32SequentialFile</code> 和 <code>Win32RandomAccessFile</code> 类中。这两个类都有一个 <code>Unref</code> 方法，这个方法会在文件不再被使用时被调用。在 <code>Unref</code> 方法中，LevelDB 会检查待删除文件列表，如果列表中的文件没有被数据库的任何部分引用，那么这个文件就会被实际删除。</p>
<p>这就是 LevelDB 如何处理合并完成后的原始 SST 文件删除的问题。具体的实现细节可能会因为 LevelDB 的版本和配置的不同而有所不同。</p>
<h3 id="读放大是什么"><a class="header" href="#读放大是什么">读放大是什么？</a></h3>
<p>读放大是指为了执行一个 get 操作，需要从磁盘读取的数据块的数量。如果有大量的 SST 文件，那么每个 get 操作可能需要从这些 SST 文件中读取多个数据块，这就会导致读放大。</p>
<p>接下来结合一个具体的例子来讲解读放大：</p>
<p>在 LevelDB 中，读放大（Read Amplification）是指为了读取一个键值对，需要进行的 I/O 操作数量。这主要是由于 LevelDB 的数据存储结构——LSM（Log-Structured Merge-tree）树造成的。</p>
<p>LSM 树由多个层级（Level）组成，每个层级包含多个 SST 文件（Sorted String Table，排序字符串表）。每个 SST 文件包含的 key-range 可能会和其他层级的 SST 文件重叠，但同一层级的 SST 文件之间的 key-range 不会重叠。</p>
<p>假设我们有一个 LevelDB 数据库，其中包含以下 SST 文件：</p>
<ul>
<li>Level 0：SST1，SST2</li>
<li>Level 1：SST3，SST4</li>
<li>Level 2：SST5，SST6，SST7</li>
</ul>
<p>现在，我们要执行一个 get 操作，查找一个键值对。首先，我们需要在 Level 0 的 SST 文件中查找。如果在 SST1 中找到了，那么我们就可以直接返回结果。如果没有找到，我们需要继续在 SST2 中查找。如果在 SST2 中也没有找到，我们需要继续在 Level 1 的 SST 文件中查找，以此类推。</p>
<p>因此，为了查找一个键值对，我们可能需要从多个 SST 文件中读取数据。这就是读放大。在这个例子中，如果我们需要从 SST1，SST2，SST3 和 SST5 中读取数据，那么读放大就是 4。</p>
<p>为了减少读放大，LevelDB 会定期进行合并（Compaction）操作。合并操作会选择一些 SST 文件，将这些文件中的数据项进行排序并合并，然后分割成多个新的 SST 文件。这个过程中，原来的数据会被重新写入磁盘，从而导致写放大。但是，合并操作可以减少 SST 文件的数量，从而减少读放大。</p>
<h3 id="为什么合并可以减少读放大"><a class="header" href="#为什么合并可以减少读放大">为什么合并可以减少读放大？</a></h3>
<p>当进行合并后，多个 SST 文件会被合并成一个更大的 SST 文件，这个文件的键范围是非重叠的。这样，当我们需要查找一个键时，我们只需要在一个 SST 文件中查找，这就大大减少了读放大。也就是说，为了获取一个键的值，我们只需要读取一个 SST 文件，因为每个键只会存在于一个 SST 文件中。</p>
<p>此外，合并过程中还会进行去重操作，只保留最新的键值对，这也有助于减少读放大。因为在没有进行合并的情况下，一个键的旧值可能会存在于多个 SST 文件中，这就需要读取多个 SST 文件才能找到这个键的最新值。但是在进行合并后，一个键的旧值会被删除，只保留最新的值，这样就只需要读取一个 SST 文件就能找到这个键的最新值。</p>
<p>因此，通过合并，我们可以将多个 SST 文件合并成一个更大的 SST 文件，减少了读放大，提高了查询效率。</p>
<h3 id="什么是写放大"><a class="header" href="#什么是写放大">什么是写放大？</a></h3>
<p>在 LevelDB 中，合并（Compaction）是一种优化操作，它的目的是减少读放大（Read Amplification）和空间放大（Space Amplification）。然而，这个操作会导致写放大（Write Amplification），即实际写入磁盘的数据量会大于用户写入的数据量。</p>
<p>在 LevelDB 中，写放大（Write Amplification）是指将数据写入磁盘时，实际写入的数据量与用户写入的数据量之比。写放大是由于 LevelDB 的合并（Compaction）操作引起的。</p>
<p>在 LevelDB 中，新写入的数据首先被存储在内存中的 MemTable 中。当 MemTable 达到一定大小时，它会被转换为 SST 文件（Sorted String Table，排序字符串表）并刷新（Flush）到磁盘。这个过程中，每写入 1MB 的数据，就会产生 1MB 的磁盘 I/O，所以没有合并的写放大比例是 1x。</p>
<p>然而，LevelDB 使用了一种名为 LSM-tree（Log-Structured Merge-tree）的数据结构，它通过在后台进行合并操作来提高写入性能。合并操作是指将多个 SST 文件合并为一个新的 SST 文件，同时删除重复的键和过期的数据。这个过程会产生大量的额外磁盘 I/O，从而导致写放大。</p>
<p>具体来说，LevelDB 的合并操作分为两级：Minor Compaction 和 Major Compaction。Minor Compaction 主要处理 MemTable 刷新到磁盘的过程，它只涉及到最新的 SST 文件，因此产生的额外磁盘 I/O 较少，对写放大的影响较小。Major Compaction 则涉及到所有的 SST 文件，它会读取所有的数据并重新写入磁盘，因此产生的额外磁盘 I/O 较多，对写放大的影响较大。</p>
<h3 id="合并对写放大的影响"><a class="header" href="#合并对写放大的影响">合并对写放大的影响？</a></h3>
<p>如果我们每次得到一个 SST 就做一次全合并，那么写入到磁盘的数据量将是刷新的 SST 数量的平方。这是因为每次合并都会生成一个新的 SST 文件，而每个新的 SST 文件都包含了所有之前的数据。这种情况下，每次合并都会对所有的 SST 文件进行读取和写入，这会导致大量的磁盘 I/O，从而导致写放大。</p>
<p>例如，如果我们将 100 个 SST 刷新到磁盘，我们将做 2 个文件，3 个文件，...，100 个文件的合并。在第一次合并时，我们将第一个和第二个 SST 文件合并成一个新的 SST 文件，这个新的 SST 文件包含了第一个和第二个 SST 文件的所有数据。在第二次合并时，我们将第一个、第二个和第三个 SST 文件合并成一个新的 SST 文件，这个新的 SST 文件包含了第一个、第二个和第三个 SST 文件的所有数据。以此类推，到第 100 次合并时，我们将所有的 SST 文件合并成一个新的 SST 文件，这个新的 SST 文件包含了所有 SST 文件的所有数据。</p>
<p>因此，实际写入到磁盘的总数据量大约是 5000 个 SST。在这种情况下，写入 100 个 SST 后的写放大将是 50x，即实际写入的数据量是用户写入的数据量的 50 倍。</p>
<p>因此，为了避免这种情况，LevelDB 在进行合并操作时，会根据 SST 文件的大小和级别进行选择，只对部分 SST 文件进行合并，从而降低写放大。</p>
<h3 id="空间放大"><a class="header" href="#空间放大">空间放大</a></h3>
<p>计算空间放大最直观的方法是将 LSM 引擎实际使用的空间除以用户空间使用量（即，数据库大小，数据库中的行数等）。引擎需要存储删除墓碑，有时如果合并不够频繁，还需要存储同一键的多个版本，因此导致空间放大。</p>
<p>在引擎端，通常很难知道用户存储的数据的确切数量，除非我们扫描整个数据库并查看引擎中有多少死版本。因此，估计空间放大的一种方法是将完整存储文件大小除以最后一层大小。这种估计方法背后的假设是，用户填充初始数据后，工作负载的插入和删除率应该相同。我们假设用户端的数据大小不变，因此最后一层包含用户数据在某一点的快照，上层包含新的更改。当合并将所有内容合并到最后一层时，我们可以使用这种估计方法得到 1x 的空间放大因子。</p>
<p>请注意，合并也需要空间 -- 在合并完成之前，你不能删除正在合并的文件。如果你对数据库进行全面的合并，你将需要与当前引擎文件大小相等的空闲存储空间。</p>
<p>在这部分，我们将有一个合并模拟器来帮助你可视化合并过程和你的合并算法的决策。我们提供最小的测试用例来检查你的合并算法的属性，你应该密切关注统计数据和合并模拟器的输出，以了解你的合并算法的工作情况。</p>
<h3 id="leveldb-是如何估计评估读写空间放大的"><a class="header" href="#leveldb-是如何估计评估读写空间放大的">Leveldb 是如何估计评估读/写/空间放大的？</a></h3>
<p>在 LevelDB 中，读放大、写放大和空间放大的估计主要依赖于 LevelDB 的内部统计信息。这些统计信息可以通过 LevelDB 的 <code>DB::GetProperty</code> 方法获取。以下是一些具体的方法：</p>
<ol>
<li>
<p>读放大：LevelDB 并没有直接提供读放大的统计信息，但我们可以通过其他的统计信息来间接估计。例如，我们可以通过 <code>leveldb.sstables</code> 属性获取到每一层的 SST 文件数量和大小，然后根据 LSM-Tree 的特性，估计出平均每次读取操作需要访问的数据块数量。</p>
</li>
<li>
<p>写放大：LevelDB 提供了 <code>leveldb.compaction.bytes-written</code> 属性，这个属性表示了由于压缩操作而写入到磁盘的数据量。我们可以将这个值除以实际写入的数据量（可以通过 <code>leveldb.bytes-written</code> 属性获取），得到写放大。</p>
</li>
<li>
<p>空间放大：LevelDB 提供了 <code>leveldb.live-sst-files-size</code> 属性，这个属性表示了当前所有 SST 文件的总大小。我们可以将这个值除以实际写入的数据量（可以通过 <code>leveldb.bytes-written</code> 属性获取），得到空间放大。</p>
</li>
</ol>
<p>具体到代码层面，我们可以通过以下的代码来获取这些统计信息：</p>
<p>以上就是在 LevelDB 中估计读放大、写放大和空间放大的方法。具体的实现可能会因为 LevelDB 的版本和配置的不同而有所不同。</p>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p>这篇文章详细介绍了LevelDB中的合并操作，包括Minor Compaction和Major Compaction，以及它们如何影响读放大、写放大和空间放大。合并操作是LevelDB优化存储空间和提高查询性能的关键，它通过减少SST文件的数量来减少读放大和空间放大，但同时会导致写放大，即实际写入磁盘的数据量大于用户写入的数据量。文章还讨论了LevelDB如何处理与合并并行的L0刷新，以及合并完成后立即删除原始SST文件的影响。最后，文章介绍了LevelDB如何估计和评估读放大、写放大和空间放大。</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../lsm/bloom-fliter.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../alg/array/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../lsm/bloom-fliter.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../alg/array/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <script type="text/javascript" charset="utf-8">
        var pagePath = "lsm/compact-detail.md"
        </script>


        <!-- Custom JS scripts -->
        <script src="../assets/custom.js"></script>
        <script src="../assets/bigPicture.js"></script>


    </div>
    </body>
</html>